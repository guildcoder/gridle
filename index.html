<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>GRIDLE</title>
<link rel="manifest" href="/manifest.json">
<style>
:root{
  --bg:#000;
  --neon-cyan:#00f0ff;
  --neon-red:#ff2b2b;
  --frame-pad:12px;
  --font: 'Orbitron', system-ui, sans-serif;
}
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

/* Scroll lock */
html, body {
  height:100%;
  margin:0;
  background:var(--bg);
  font-family:var(--font);
  overflow:hidden;
  touch-action:none;
  -webkit-user-select:none;
  user-select:none;
}

.app{
  height:100vh;
  width:100vw;
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  padding:12px;
  box-sizing:border-box;
}

.title-wrap { position:relative; width:100%; display:flex; justify-content:center; pointer-events:none; margin-bottom:6px; }
.title { font-family: 'Orbitron', monospace; color:var(--neon-cyan); letter-spacing:6px; font-size:32px; transform: translateY(0);
  text-shadow:0 0 8px rgba(0,240,255,0.75),0 0 28px rgba(0,240,255,0.15); opacity:1; transition: transform .4s ease, opacity .35s ease; font-style: italic; }
.title-small { font-size:20px; letter-spacing:3px; color:#88faff; opacity:0.9; }

.streak { margin-top:6px; color:var(--neon-cyan); font-size:12px; opacity:0.9; text-shadow: 0 0 8px rgba(0,240,255,0.12); pointer-events:none; }

.frame{
  width:min(96vw,520px);
  max-height:92vh;
  background:#000;
  border-radius:14px;
  position:relative;
  box-shadow:0 0 30px rgba(0,255,255,0.05);
  display:flex;
  align-items:center;
  justify-content:center;
  padding:var(--frame-pad);
  border:4px solid rgba(0,255,255,0.06);
  outline:2px solid rgba(0,255,255,0.12);
  overflow:hidden;
}
.frame::after{
  content:'';
  position:absolute;
  inset:calc(var(--frame-pad) - 6px);
  border-radius:12px;
  box-shadow:0 0 28px var(--neon-cyan), inset 0 0 10px rgba(0,255,255,0.04);
  pointer-events:none;
}

canvas.game {
  width:100%;
  height:100%;
  border-radius:8px;
  background:#000;
  display:block;
  image-rendering: pixelated;
}

.controls { width:100%; max-width:520px; margin-top:10px; display:flex; justify-content:center; gap:12px; align-items:center; }
.button { background:#000; border:2px solid var(--neon-cyan); color:var(--neon-cyan); padding:10px 14px; border-radius:10px; font-weight:700; min-width:160px; text-align:center; cursor:pointer; box-shadow:0 6px 18px rgba(0,255,255,0.06); }
.button.hidden{ display:none; }

.meta { margin-top:8px; color:#0ff; font-size:12px; opacity:0.8; text-align:center; width:100%; max-width:520px; }

.title-hidden { transform: translateY(-30px); opacity:0; pointer-events:none; }
</style>
</head>
<body>
<div class="app" id="app">
  <div class="title-wrap">
    <div style="display:flex;flex-direction:column;align-items:center;">
      <div id="title" class="title">GRIDLE</div>
      <div id="streakDisplay" class="streak">ðŸ”¥ Streak: 0</div>
    </div>
  </div>

  <div class="frame" id="game-frame">
    <canvas id="game" class="game"></canvas>
  </div>

  <div class="controls" id="controls">
    <button id="playBtn" class="button">Play Today's Challenge</button>
  </div>

  <div class="meta">Gridle â€” Daily Grid Challenge. Central Time reset at midnight. Use arrows/WASD. Space to throw disc.</div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', {alpha:false});

function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  const size = Math.min(rect.width, rect.height);
  canvas.width = canvas.height = size * devicePixelRatio;
}
window.addEventListener('resize', resizeCanvas);

//// Utilities
function mulberry32(a){ return function(){ var t = a += 0x6D2B79F5|0; t = Math.imul(t ^ t>>>15, t | 1); t ^= t + Math.imul(t ^ t>>>7, t | 61); return ((t ^ t>>>14) >>> 0) / 4294967296; } }
function getCentralDateKey(){ const now = new Date(); const tz = 'America/Chicago'; const df = new Intl.DateTimeFormat('en-US',{timeZone:tz,year:'numeric',month:'2-digit',day:'2-digit'}); const parts=df.formatToParts(now); const y=parts.find(p=>p.type==='year').value,m=parts.find(p=>p.type==='month').value,d=parts.find(p=>p.type==='day').value; return `${y}-${m}-${d}`; }

//// Game Setup
let gameState=null;
const DIRS=[{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0},{dx:0,dy:-1}];
let TICK_MS = 180; // slower

function makeDailySetup(dateKey){
  const seed=parseInt(dateKey.replace(/-/g,''),10);
  const rng = mulberry32(seed);
  const sizes=[20,22,24,26,28,30];
  const N=sizes[Math.floor(rng()*sizes.length)];
  const maxBots=Math.max(1,Math.floor(N/4));
  const botsCount=Math.floor(rng()*Math.min(6,maxBots))+1;
  const bots=[];
  for(let b=0;b<botsCount;b++){
    const edge=b%4; let x=0,y=0,dir=0;
    if(edge===0){ x=1;y=1+Math.floor(rng()*(N-2)); dir=0; }
    if(edge===1){ x=N-2;y=1+Math.floor(rng()*(N-2)); dir=2; }
    if(edge===2){ y=1;x=1+Math.floor(rng()*(N-2)); dir=1; }
    if(edge===3){ y=N-2;x=1+Math.floor(rng()*(N-2)); dir=3; }
    bots.push({id:`bot${b}`,x,y,dir,alive:true});
  }
  const userStart={x:Math.floor(N/2),y:Math.floor(N*0.75),dir:3};
  return {N,userStart,bots,maxTicks:N*N*8};
}

function initGame(){
  const dateKey=getCentralDateKey();
  const setup=makeDailySetup(dateKey);
  const N=setup.N;
  const grid=Array.from({length:N},()=>Array(N).fill(0));
  const user={x:setup.userStart.x,y:setup.userStart.y,dir:setup.userStart.dir,alive:true,disc:null};
  grid[user.y][user.x]='user';
  const bots=setup.bots.map(b=>{grid[b.y][b.x]=b.id; return {...b};});
  gameState={N,grid,user,bots,running:false,tick:0,setup,finished:false};
  resizeCanvas(); render();
  updateStreakDisplay();
}

//// Rendering
function render(){
  if(!gameState) return;
  const {N,grid}=gameState;
  const w=canvas.width,h=canvas.height;
  const tile=Math.floor(w/N);
  ctx.fillStyle='#000'; ctx.fillRect(0,0,w,h);

  // Grid background with inner neon lines
  ctx.fillStyle='#010101'; ctx.fillRect(0,0,N*tile,N*tile);
  ctx.strokeStyle='rgba(0,240,255,0.2)'; ctx.lineWidth=1;
  for(let i=0;i<=N;i++){
    ctx.beginPath();
    ctx.moveTo(i*tile,0); ctx.lineTo(i*tile,N*tile); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0,i*tile); ctx.lineTo(N*tile,i*tile); ctx.stroke();
  }

  // Bikes
  const drawBike=(x,y,color)=>{
    ctx.fillStyle=color; ctx.fillRect(x*tile+tile*0.15,y*tile+tile*0.15,tile*0.7,tile*0.7);
  }
  if(gameState.user.alive) drawBike(gameState.user.x,gameState.user.y,'rgba(0,240,255,1)');
  gameState.bots.forEach(b=>{ if(b.alive) drawBike(b.x,b.y,'rgba(255,43,43,1)'); });

  // Discs
  const discs=[];
  if(gameState.user.disc) discs.push(gameState.user.disc);
  gameState.bots.forEach(b=>{ if(b.disc) discs.push(b.disc); });
  discs.forEach(d=>{
    ctx.beginPath();
    ctx.arc(d.x*tile+tile/2,d.y*tile+tile/2,tile*0.25,0,Math.PI*2);
    ctx.fillStyle=d.owner==='user'?'rgba(0,240,255,1)':'rgba(255,43,43,1)';
    ctx.fill();
  });
}

//// Game Loop
function step(){
  if(!gameState||gameState.finished) return;
  const {N,grid,user,bots}=gameState;

  // Move user
  if(user.alive){
    const nd=DIRS[user.dir];
    const nx=user.x+nd.dx, ny=user.y+nd.dy;
    if(nx<0||nx>=N||ny<0||ny>=N||grid[ny][nx]!==0) user.alive=false;
    else { grid[user.y][user.x]='user'; user.x=nx; user.y=ny; grid[ny][nx]='user'; }
  }

  // Bots simple: try forward, else random
  bots.forEach(bot=>{
    if(!bot.alive) return;
    let nd=DIRS[bot.dir];
    let nx=bot.x+nd.dx, ny=bot.y+nd.dy;
    if(nx<0||nx>=N||ny<0||ny>=N||grid[ny][nx]!==0){
      bot.dir=Math.floor(Math.random()*4);
      nd=DIRS[bot.dir]; nx=bot.x+nd.dx; ny=bot
            ny=bot.y+nd.dy;
      if(nx<0||nx>=N||ny<0||ny>=N||grid[ny][nx]!==0){
        bot.alive=false; // bot crashes
        return;
      }
    }
    grid[bot.y][bot.x]=bot.id;
    bot.x=nx; bot.y=ny;
    grid[ny][nx]=bot.id;
  });

  // Check end
  const aliveCount = (user.alive?1:0) + bots.filter(b=>b.alive).length;
  if(aliveCount<=1){
    gameState.finished=true;
    if(user.alive){
      incrementStreak();
      alert('You survived! ðŸ”¥');
    } else {
      resetStreak();
      alert('You crashed. Try again tomorrow.');
    }
  }

  render();
  gameState.tick++;
}

//// Streak logic
function getStreak(){ return parseInt(localStorage.getItem('gridleStreak')||'0',10); }
function updateStreakDisplay(){ document.getElementById('streakDisplay').textContent=`ðŸ”¥ Streak: ${getStreak()}`; }
function incrementStreak(){
  let s=getStreak(); s++; localStorage.setItem('gridleStreak',s); updateStreakDisplay();
}
function resetStreak(){ localStorage.setItem('gridleStreak','0'); updateStreakDisplay(); }

//// Controls
document.addEventListener('keydown',e=>{
  if(!gameState||!gameState.user.alive) return;
  switch(e.key){
    case 'ArrowUp': case 'w': gameState.user.dir=3; break;
    case 'ArrowDown': case 's': gameState.user.dir=1; break;
    case 'ArrowLeft': case 'a': gameState.user.dir=2; break;
    case 'ArrowRight': case 'd': gameState.user.dir=0; break;
    case ' ': // space disc
      gameState.user.disc={x:gameState.user.x, y:gameState.user.y, owner:'user'};
      break;
  }
});

document.getElementById('playBtn').addEventListener('click',()=>{
  initGame();
  gameState.running=true;
  const loop = setInterval(()=>{
    if(!gameState.running) { clearInterval(loop); return; }
    step();
  }, TICK_MS);
});

//// Initial setup
initGame();
</script>
</body>
</html>